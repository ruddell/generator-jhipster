<%#
Copyright 2013-2018 the original author or authors from the JHipster project.

This file is part of the JHipster project, see https://www.jhipster.tech/
for more information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-%>
/* tslint:disable no-unused-expression */
import { browser, element, by } from 'protractor';

import SignInPage from '../../page-objects/signin-page';
import NavBarPage from '../../page-objects/navbar-page';
<%_ if (authenticationType !== 'oauth2') { _%>
import RegisterPage from '../../page-objects/register-page';
import PasswordPage from '../../page-objects/password-page';
import SettingsPage from '../../page-objects/settings-page';
import {
  getToastByInnerText,
  getUserDeactivatedButtonByLogin,
  waitUntilDisplayed,
  waitUntilHidden
} from '../../util/utils';
<%_ } else { _%>
import { waitUntilDisplayed } from '../../util/utils';
<%_ } _%>

const expect = chai.expect;

describe('Account', () => {
  let navBarPage: NavBarPage;
  let signInPage: SignInPage;
  <%_ if (authenticationType !== 'oauth2') { _%>
  let passwordPage: PasswordPage;
  let settingsPage: SettingsPage;
  let registerPage: RegisterPage;

  const registerPageTitle = 'register-title';
  const passwordPageTitle = 'password-title';
  const settingsPageTitle = 'settings-title';
  <%_ } _%>
  const loginPageTitle = 'login-title';

  before(async () => {
    await browser.get('/');
    navBarPage = new NavBarPage(true);
    signInPage = await navBarPage.getSignInPage();
  });


  it('should fail to login with bad password', async () => {
    <%_ if (authenticationType !== 'oauth2') { _%>
    // Login page should appear
    expect(await signInPage.getTitle()).to.eq(loginPageTitle);

    await signInPage.setUserName('admin');
    await signInPage.setPassword('foo');
    await signInPage.login();

    // Login page should stay open when login fails
    expect(await signInPage.getTitle()).to.eq(loginPageTitle);
    <%_ } else { _%>
    signInPage.loginWithOAuth('admin', 'foo');
    const alert = element(by.css('.alert-error'));
    if (await alert.isPresent()) {
      // Keycloak
      expect(await alert.getText()).to.eq('Invalid username or password.');
    } else {
      // Okta
      const error = element(by.css('.infobox-error'));
      waitUntilDisplayed(error);
      expect(await error.getText()).to.eq('Sign in failed!');
    }
    await signInPage.clearUserName();
    await signInPage.clearPassword();
    <%_ } _%>
  });


  it('should login with admin account', async () => {
    <%_ if (authenticationType !== 'oauth2') { _%>
    await browser.get('/');
    await navBarPage.getSignInPage();

    expect(await signInPage.getTitle()).to.eq(loginPageTitle);
    
    await signInPage.setUserName('admin');
    await signInPage.setPassword('admin');
    await signInPage.login();

    await signInPage.waitUntilHidden();

    // Login page should close when login success
    expect(await signInPage.isHidden()()).to.be.true;
    await navBarPage.autoSignOut();
    <%_ } else { _%>
    // Keycloak credentials by default, change them to be able to use oauth2 with Okta
    signInPage.loginWithOAuth('admin', 'admin');
    const success = element(by.className('alert-success'));
    waitUntilDisplayed(success);
    // Success alert should appear in home page
    expect(await success.isPresent()).to.be.true;
    <%_ } _%>
  });


  <%_ if (authenticationType !== 'oauth2') { _%>

  it('should be able to sign up', async () => {
    registerPage = await navBarPage.getRegisterPage();
    expect(await registerPage.getTitle()).to.eq(registerPageTitle);

    await registerPage.autoSignUpUsing('user_test', 'admin@localhost.jh', 'user_test');
    const toast = getToastByInnerText('Registration saved! Please check your email for confirmation.');
    await waitUntilDisplayed(toast);

    // Success toast should appear
    expect(await toast.isPresent()).to.be.true;
  });


  it('should not be able to sign up if login already taken', async () => {
    await registerPage.save();

    const toast = getToastByInnerText('Login name already used!');
    await waitUntilDisplayed(toast);

    // Error toast should appear
    expect(await toast.isPresent()).to.be.true;
  });


  it('should not be able to sign up if email already taken', async () => {
    expect(await registerPage.getTitle()).to.eq(registerPageTitle);

    await registerPage.username.clear();
    await registerPage.setUserName('user_test2');
    await registerPage.save();
    const toast = getToastByInnerText('Email is already in use!');
    await waitUntilDisplayed(toast);

    // Error toast should appear
    expect(await toast.isPresent()).to.be.true;
  });

  it('should activate the new registered user', async () => {
    await navBarPage.autoSignIn();
    await signInPage.waitUntilHidden();
    await navBarPage.clickOnAdminMenuItem('user-management');
    const deactivatedButton = getUserDeactivatedButtonByLogin('user_test');
    await waitUntilDisplayed(deactivatedButton);
    await deactivatedButton.click();
    await waitUntilHidden(deactivatedButton);

    // Deactivated button should disappear
    expect(await deactivatedButton.isPresent()).to.be.false;
    await navBarPage.autoSignOut();
  });

  it('should be able to log in with new registered account', async () => {
    await signInPage.get();
    expect(await signInPage.getTitle()).to.eq(loginPageTitle);

    await signInPage.autoSignInUsing('user_test', 'user_test');
    await signInPage.waitUntilHidden();

    // Login page should close when login success
    expect(await signInPage.isHidden()()).to.be.true;
    await navBarPage.autoSignOut();
  });

  it('should fail to update password when using incorrect current password', async () => {
    await navBarPage.autoSignIn();
    await signInPage.waitUntilHidden();
    passwordPage = await navBarPage.getPasswordPage();
    expect(await passwordPage.getTitle()).to.eq(passwordPageTitle);

    await passwordPage.autoChangePassword('wrong_current_password', 'new_password', 'new_password');
    const toast = getToastByInnerText('An error has occurred! The password could not be changed.');
    await waitUntilDisplayed(toast);

    // Error toast should appear
    expect(await toast.isPresent()).to.be.true;
  });


  it('should be able to update password', async () => {
    expect(await passwordPage.getTitle()).to.eq(passwordPageTitle);
   
    await passwordPage.currentPassword.clear();
    await passwordPage.currentPassword.sendKeys('admin');
    await passwordPage.save();
    const toast = getToastByInnerText('Password changed!');
    await waitUntilDisplayed(toast);

    // Success toast should appear
    expect(await toast.isPresent()).to.be.true;
    await navBarPage.autoSignOut();
  });


  it('should be able to log in with new password', async () => {
    await signInPage.get();
    expect(await signInPage.getTitle()).to.eq(loginPageTitle);

    await signInPage.setUserName('admin');
    await signInPage.setPassword('new_password');
    await signInPage.login();
    await signInPage.waitUntilHidden();
    expect(await signInPage.isHidden()()).to.be.true;

    // change back to default
    await passwordPage.get();
    expect(await passwordPage.getTitle()).to.eq(passwordPageTitle);

    await passwordPage.autoChangePassword('new_password', 'admin', 'admin');
    
    await navBarPage.autoSignOut();
  });


  it('should be able to change settings', async () => {
    await signInPage.get();
    await signInPage.autoSignInUsing('user_test', 'user_test');
    await signInPage.waitUntilHidden();
    settingsPage = await navBarPage.getSettingsPage();
    expect(await settingsPage.getTitle()).to.eq(settingsPageTitle);

    await settingsPage.setFirstName('jhipster');
    await settingsPage.setLastName('retspihj');
    await settingsPage.save();

    const toast = getToastByInnerText('Settings saved!');
    await waitUntilDisplayed(toast);

    // Success toast should appear
    expect(await toast.isPresent()).to.be.true;
    await navBarPage.autoSignOut();
  });


  it('should not be able to change settings if email already exists', async () => {
    await navBarPage.autoSignIn();
    await signInPage.waitUntilHidden();
    await navBarPage.getSettingsPage();
    expect(await settingsPage.getTitle()).to.eq(settingsPageTitle);

    await settingsPage.email.sendKeys('.jh');
    await settingsPage.save();

    const toast = getToastByInnerText('Email is already in use!');
    await waitUntilDisplayed(toast);

    // Error toast should appear
    expect(await toast.isPresent()).to.be.true;
  });


  it('should delete previously created fake user', async () => {
    await browser.get('#/admin/user-management/user_test/delete');
    const deleteModal = element(by.className('modal'));
    await waitUntilDisplayed(deleteModal);
    await element(by.buttonText('Delete')).click();
    // Delete modal should disappear
    expect(await deleteModal.isPresent()).to.be.false;
  });
  -%>
  <%_ } _%>

  after(async () => await navBarPage.autoSignOut());
});